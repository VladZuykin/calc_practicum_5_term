\chapter{Задание №1 -- точные методы решения СЛАУ}
\section{Задание №1.0 -- метод Гаусса}
\subsection{Условие задания №1.0}
Разработать программу, которая реализует решение СЛАУ методом Гаусса в соответствии с вариантом, в том числе выполнить:
\begin{itemize}
\item предварительную оценку системы (сделать выводы),
\item реализовать в методе выбор главного элемента по столбцу,
\item посчитать количество операций, и сравнить с тем, что указано в теоретической справке,
\item найти определитель матрицы коэффициентов СЛАУ,
\item рассмотреть матрицу вида $$A_{ij}=\frac1{i+j-1},\; i,j=1,...,n.$$
    Положить точное решение СЛАУ $$x=(x_1,...,x_n)^T=(1,...,1)^T,$$ из него найти правую часть b. С учетом найденной правой части
попробовать решить получившуюся СЛАУ относительно неизвестного вектора x.
\end{itemize}

\subsection{О коде задания №1.0}
Для предварительной оценки сначала вычисляется определитель данной матрицы. В программе это делается с помощью функции \mintinline{python}|np.linalg.det| библиотеки \mintinline{python}|numpy| в методе \mintinline{python}|invertible| класса \mintinline{python}|Matrix|. Позже рассчитывается число обусловленности матрицы, для чего используется алгоритм получения обратной матрицы. Число обусловленности рассчитывается для трёх матричных метрик:
\begin{itemize}
\item $||A||_1=\max\limits_{1\leq j\leq n}
(\sum\limits_{j=1}^n|a_{ij}|)$ -- подчинённая к $||v||_1$.

\item $||A||=\sqrt{\max\limits_{1\leq j\leq n}
\lambda_j(A^*A)}$ -- подчинённая к $||v||_2$.

\item $||A||_\infty=\max\limits_{1\leq i\leq n}
(\sum\limits_{j=1}^n|a_{ij}|)$ -- подчинённая к $||v||_\infty$.
\end{itemize}
Для их вычисления используются следующие методы класса \mintinline{python}|Matrix|: \mintinline[breakanywhere]{python}|inverse_matrix| -- вычисление обратной матрицы, \mintinline{python}|condition_number| -- для вычисления числа обусловленности, методы \mintinline[breakanywhere]{python}|matrix_1_subordinate_norm|, \mintinline{python}|matrix_2_subordinate_norm|, \mintinline{python}|matrix_infty_subordinate_norm| для вычисления норм, подчинённых соответствующим нормам Гёльдера вектора.

Сам класс \mintinline{python}|Matrix| статичен: состоит из самой матриц и столбца b, передающихся в него при инициализации и не изменяющихся. Для прямого метода Гаусса используется метод \mintinline{python}|__inner_fwd_elimination|, он сохраняет перестановку столбцов в массиве \mintinline{python}|self._fwd_eliminated_matrix_cols|, число операций в переменной \mintinline{python}|self._fwd_elimination_operations_num|. Позже это число операций можно получить с помощью метода-свойства \mintinline{python}|fwd_elimination_operations_num|.

Для получения полученной после прямого метода Гаусса матрицы используется метод-свойство \mintinline{python}|fwd_eliminated|. Для обратного метода Гаусса используется метод-свойство \mintinline{python}|gaussian_solution|, внутри которого используется метод \mintinline{python}|back_substitution_upper|. Для получения количества операций обратного метода Гаусса используется метод-свойство \mintinline{python}|back_substitution_operations_num|.

Код программы первого задания (не включая сам класс) указан в листинге task1.py.
\subsection{Вывод программы для варианта №13}
\lstinputlisting[keepspaces=true, breakatwhitespace=true, breaklines=true]{output/task1_0.txt}
\subsection{Листинг task1.py}
\inputminted{python}{code/task1.py}

\section{Задание №1.5 -- LU-разложение}
\subsection{Условие задания №1.5}
Используя наработки из предыдущей части работы, модифицировать
программу, выполняющую метод Гаусса. Определить матрицы $U$ и $L$.
Посчитать определитель.

Решить систему вида (24) два раза, первый раз используя входные
данные из работы №1 от 07.09.2023, второй раз — заменить правую часть
на самостоятельно сгенерированную. Для ее нахождения рекомендуется
использовать вектор $x$, элементы которого удовлетворяют условию
$$f_X(x) = \begin{cases}
   \frac1{b-a},\ x \in [a, b]
   \\
   0,\ x \notin [a,b]
 \end{cases},$$
$a=-10,\ b=10.$ Сравнить число арифметических операций.

\subsection{Немного теории}
LU-разложение матрицы $A$ существует, если её главные миноры не вырождены.

Смысл $LU$ метода заключается в том, что для решения системы $LUx=b$, при разложении в $A=LU$ один раз за $O(n^3)$, потребуется лишь выполнить обратную подстановку два раза: $Ly=b,\ Ux=y$, сложность будет $O(n^2)$, в отличие от $O(n^3)$ при методе Гаусса. То есть при неоднократном решении систем с одинаковой $A$ $LU$ -- разложение будет выгоднее.

\subsection{О коде задания №1.5}
Для получения решения, полученного LU методом, используется метод-свойство \mintinline{python}|lup_solution|, полученные в его процессе L и U матрицы затем можно получить с помощью методов-свойств \mintinline{python}|l_lup_matrix| и \mintinline{python}|u_lup_matrix|. Эти матрицы храняться в переменных \mintinline{python}|self._l_lup_matrix| и \mintinline{python}|
self._u_lup_matrix|.

Чтобы получить число арифметических действий при разделении матриц используется метод-свойство \mintinline{python}|lup_fwd_operations_num|, чтоб получить число арифметических действий при решении двух уравнений используется метод-свойство \mintinline{python}|lup_sub_operations_num|.
\subsection{Вывод программы для варианта №13}
\lstinputlisting{output/task1_5.txt}
\subsection{Листинг task 1\_5.py}
\inputminted{python}{code/task1_5.py}

\section{Задание №1.75 -- метод Холецкого (метод квадратных корней)}
\subsection{Условие задания №1.75}
Задание:
\begin{itemize}
    \item Проверить входные данные в соответствии с вариантом;
    \item Реализовать метод Холецкого;
    \item Решить СЛАУ в соответствии с вариантом;
    \item Оценить число операций.
\end{itemize}
\subsection{Немного теории}
Для разложения Холецкого требуется симметричность и положительная определённость матрицы.

Он позволяет с меньшим количеством операций относительно обычного $LU$ разложения вычислить $L:\ LL^*=A$ для симметричной положительно определённой матрицы.
\subsection{О коде №1.75}
Для проверки входных данных используются методы \mintinline{python}|is_symmetrix|, \mintinline{python}|is_positive_determined|, которые проверяют симметричность и положительную определённость (реализовано через нахождение миноров) матрицы соответственно.

Для получения решения методом Холецкого и числа операций используется метод \mintinline{python}|solve_cholesky|.

\subsection{Листинг task1\_75.py}
\inputminted{python}{code/task1_75.py}

\section{Задание №1.825 -- метод Прогонки}
\subsection{Условие задания №1.825}
Разработать программу, выполняющую метод прогонки для решения
СЛАУ. Оценить число операций.
\subsection{Немного теории}
Метод Прогонки помогает решить СЛАУ за O(n), если матрица трёхдиагональна и удовлетворяет условиям $|b_k| \geq |a_k| + |c_k|$ и $|b_k| > |a_k|$.
\subsection{О коде №1.825}
Сначала матрица проверяется на возможность использования в методе прогонки. Для этого проверяется, является ли она трёхдиагональной, удовлетворяет ли она условиям:
\begin{itemize}
    \item $|b_k| \geq |a_k| + |c_k|$;
    \item $|b_k| > |a_k|$
\end{itemize}
при $i=1,...,n$ в методах \mintinline{python}|is_tridiagonal| и \mintinline{python}|tridiagonal_algorithm_processable| соответственно.
Решение методом прогонки и количество произведённых операций можно получить, используя метод \mintinline{python}|tridiagonal_method| класса \mintinline{python}|Matrix|.

\subsection{Вывод программы для тестового примера}
\lstinputlisting{output/task1_75.txt}
\subsection{Листинг task1\_825.py}
\inputminted{python}{code/task1_825.py}

\chapter{Задание №2 -- итерационные методы решения СЛАУ}
\section{Условие задания №2}
Дана система линейных алгебраических уравнений
\begin{equation}
    \label{sale}
    Ax=b
\end{equation}
\begin{enumerate}
\item Найти решение системы (\ref{sale}) методом Гаусса, положим его как точное решение и обозначим $x^*$.
\item Преобразовать исходную систему к системе вида
\begin{equation}
\label{good_sale}
    x = Bx + c,
\end{equation}
где $B=E-D^{-1}A$, $c=D^{-1}b$. Здесь $D$ -- диагональная матрица, у
которой на главной диагонали находятся диагональные элементы
матрицы $A$. Вычислить $||B||_\infty$.
\item  Вычислить априорную оценку погрешности $||x^{(k)}-x^*||$.
\item Вычислить приближение $x^{(k)}$ методом простой итерации. Вывести
его фактическую погрешность, апостериорную оценку, априорную
оценку.
\item Вычислить приближение $x^{(k)}$ к решению системы (\ref{good_sale}) методом Зейделя. Вывести его фактическую погрешность. Сравнить с решением, полученным методом простой итерации.
\end{enumerate}

\section{Немного теории}
Необходимое и достаточное условие сходимости метода простой итерации:
$\rho(B) < 1$, где $\rho(B)$ -- спектральный радиус матрицы B.
Достаточное условие:
$||H|| < 1$, где указанная норма мультипликативная.

Достаточные условия сходимости метода Зейделя: $||H||_\infty<1$ или $||H||_1<1$.

\section{О коде задания №2}
Метод \mintinline{python}|get_simple_iteration_method_matrices| позволяет получить разложение системы (\ref{sale}) в виде (\ref{good_sale}). Норму полученной матрицы $B$ можно получить, используя метод класса \mintinline{python}|Matrix.matrix_infty_subordinate_norm|.

Чтобы получить априорную оценку используется метод \mintinline{python}|sim_a_priori_estimate|, полученное значение $x^{(k)}$,  апостериорную погрешность можно получить при применении метода \mintinline{python}|simple_iteration_method|. Фактическую погрешность поможет вычислить метод \mintinline{python}|sim_actual_error|.

Решение методом Зейделя можно получить, используя \mintinline{python}|seidel_method|, фактическая погрешность снова может быть вычислена с использованием метода \mintinline{python}|sim_actual_error|.

\subsection{Вывод программы для тестового примера}
\lstinputlisting{output/task2.txt}
\section{Листинг task2.py}
\inputminted{python}{code/task2.py}

\chapter{Задание №3 -- Частичная и полная проблемы собственных значений}
\section{Условие задания №3}
\begin{enumerate}
    \item Найти степенным методом с заданной точностью $\varepsilon$ максимальное по модулю собственное число $\lambda_1$ матрицы $A$ и соответствующий ему собственный вектор $x^{(1)}$ так, чтобы $||x^{(1)}||_2=1$.
    \item Используя QR-алгоритм вычислить $\lambda_1,...,\lambda_n$.
    \item  Из последовательности собственных чисел, полученных в результате предыдущего пункта, выбрать некоторое число $\lambda_j$ и найти соответствующий ему собственный вектор используя метод обратных
итераций.

\end{enumerate}
\section{Немного теории}
Для работы степенного метода достаточно следующее условие: собственное значение, у которого модуль максимален, единственно.

\section{О коде задания №3}
 Метод \mintinline{python}|power_method| класса \mintinline{python}|Matrix| поможет получить собственный вектор, собственное число, количество шагов, требующихся для получения собственного числа с указанной точностью степенным методом.

 QR-алгоритм реализуется методом \mintinline{python}|qr_algorithm|, в нём используется метод \mintinline{python}|rotation_method_qr_decomposition| QR-разложения методом вращения.

 Для собственного числа из полученных QR-алгоритмом находится соответствующее ему собственное число методом \mintinline{python}|inverse_iteration_method|.

\section{Вывод программы для тестового примера}
\lstinputlisting{output/task3.txt}
\section{Листинг task3.py}
\inputminted{python}{code/task3.py}

\chapter{Задача №4 -- Решение краевых задач для ОДУ}
\section{Условие задачи №4}
Задача
$$y''+p(x)y'+q(x) = f(x),\ 0<x<1,$$
условия $y(0)=a,\ y(1) = b$.

\section{Описание метода}
Вводим сетку: $x_k=kh,\ k \in 0: n,\ h = 1/n.$ Численно продифференцируем $y''$ и получим:
$$\frac{y_{k+1}-2y_k+y_{k-1}}{h^2} + p_k\frac{y_{k+1}-y_k}{2h} + q(x_k)y(x_k) = f(x_k),\ k \in 1: n - 1,$$
$$y_0 = a,\ y_n = b.$$
Соберём
$$y_{k+1}(\frac{1}{h^2} + \frac{p_k}{2h}) + y_k (-\frac{2}{h^2} + q_k) + y_{k-1}(\frac{1}{h^2} - \frac{p_k}{2h})=f_k,\ k \in 1: n -1 $$
и перепишем 
$$a_ky_{k+1} + b_ky_k+c_ky_{k-1}=f_k$$
$$y_0 = a,\ y_n = b$$
получили трёхдиагональную матрицу. Если $h\rightarrow0$, то $a_k>0,\ c_k >0,\ b_k < 0.$

Пусть $q(x) > 0:$
$$|b_k|=-b_k=\frac2{n^2}-q_k$$
$$|a_k|+|c_k|=a_k+c_k=\frac2{h^2}.$$
Пусть $q(x) < 0:$
$$|b_k|>|a_k| + |c_k|.$$

{
\theorem
    Пусть $\forall k\ |b_k| > |a_k| + |c_k|.$ Тогда метод прогонки осуществим $(c_k\alpha_{k-1}+ b\neq0)$ и устойчив, то есть $\alpha_k\leq1$ (иначе ошибка будет расти).
}

\section{О коде задания №4}
Функция \mintinline{python}|get_x_row| возвращает равномерно заполненный массив из $n$ значений: от $x_0$ до $x_{n-1}$.

Функция \mintinline{python}|get_function_row| возвращает массив значений функции $f_(x_i)$.

Функция \mintinline{python}|get_boundary_value_problem_matrix| получает $p(x_k), q(x_k), f(x_k),\\ h, n, a, b$ и возвращает заполненную трёхдиагональную матрицу, решение которой будет являться приближёнными значениями $y(x_k)$ одного из решений дифференциального уравнения.

\section{Листинг boundary\_value\_task.py}
\inputminted{python}{code/boundary_value_task.py}

\section{Вывод программы для тестового примера}

\lstinputlisting{output/boundary.txt}


\chapter{Задание №5 -- Методы решения уравнений Фредгольма II рода}
\section{Условие задачи №5}
Линейное уравнение Фредгольма II рода имеет следующий вид:
$$y(x) - \lambda\int_a^bK(x,s)y(s)ds = f(x),\ x \in [a,b].$$
Здесь $y(x)$ — неизвестная функция, $K(x, s)$ — ядро интегрального уравнения, $f(x)$ — свободный член (правая часть) интегрального уравнения. 

Будем считать, что правая часть уравнения непрерывна на отрезке $[a, b]$, а его решение будем разыскивать в
классе непрерывных на $[a, b]$ функций.
\section{Описание метода}
Найдем приближенное решение уравнения методом квадратур. Построим на отрезке $[a, b]$ сетку с узлами
$x_1, x_2, . . . , x_n$. Запишем уравнение в узлах сетки:
$$y(x_i) - \lambda\int_a^bK(x_i,s)y(s)ds = f(x_i),\ i=1,...,n.$$
Аппроксимируем интегралы в равенствах конечными суммами с
помощью одной из квадратурных формул:
$$y_i - \lambda\sum_{j=1}^nA_jK_{ij}y_j = f_i,\ i=1,...,n.$$
Здесь $y_i = \widetilde y(x_i),\ f_i = f(x_i),\ K_{ij} = K(x_i, x_j),\ \widetilde y$ — приближение к
искомой функции $y$, $A_j$ — веса квадратурной формулы.


Решение системы уравнений дает приближенные значения искомой функции в узлах $x_i$. По ним с помощью интерполяции можно построить приближенное решение интегрального уравнения на всем отрезке $[a, b]$.

Пусть сетка $x_1, x_2, . . . , x_n$ — равномерная с шагом $h$. Используем квадратурную формулу трапеций. Тогда система линейных
алгебраических уравнений примет следующий вид:
$$y_i - \lambda h\sum_{j=1}^nw_jK_{ij}y_j = f_i,\ i=1,...,n,$$
где $w_1 = w_n = 1/2,\ w_j = 1$ при $j = 2, 3, . . . , n - 1$.

\section{О коде задания №5}
Функция \mintinline{python}|find_solution| находит значения в точках $x_i$. На вход она принимает значения $w_j$ и квадратную матрицу $K$, определяющую значения $K(x_i, x_j)$. Также она принимает массив $f(x_i)$, $h$ и $lamb=1$ -- множитель.
Она просто заполняет квадратную матрицу значениями, находит решение методом Гаусса.

Функция \mintinline{python}|trapezoid_coeffs| возвращает $(w_i)_{i=1}^n$ -- коэффициенты составной формулы трапеций. 

Функция \mintinline{python}|get_x_row| равномерно возвращает массив из $n$ значений: от $x_0$ до $x_{n-1}$.

Также функции \mintinline{python}|get_function_row| и \mintinline{python}|get_kernel_matrix| возвращает массив значений функции $f_(x_i)$ и матрицу значений $K(x_i, x_j)$ соответственно.

\section{Листинг integral\_eq\_task.py}
Функции $K(x,s)$ и $f(x)$ взяты из примера 4 стр. 24 учебного пособия <<Численные методы решения интегральных уравнений и комплекс программ на языке Matlab>>  Е.М. Карчевского 2017г.
Значения $a,b,\lambda,h$ также взяты оттуда.
Их можно увидеть в коде в функции \mintinline{python}|book_example|.
\inputminted{python}{code/integral_eq_task.py}

\section{Вывод программы для тестового примера}
Вывод сходится со значениями примера 4 стр. 24 учебного пособия <<Численные методы решения интегральных уравнений и комплекс программ на языке Matlab>> Е.М. Карчевского 2017г.
\lstinputlisting{output/integral_eq.txt}

\chapter{Код класса Matrix.}
\label{matrix_class}
\inputminted{python}{code/classes.py}